# Результаты

## Описание решения
Для решения задачи выбран C++, т.к., позволяет напрямую управление памятью. Таким образом мы имеем не упрощенное понимание процесса с одной операцией перемещения объекта. Над элементами (объектами) динамического массива могут выполняться 5 различных операций:

- копирующее конструирование;
- перемещающее конструирование;
- копирующее присваивание;
- перемещающее присваивание;
- уничтожение.

«Стоимость» операций может быть разной, в зависимости от типа объекта. Динамические массивы были реализованы с разборчивостью к этим операциям.

Фактически был реализован собственный `std::vector`, который в компиляторе MSVC является аналогом `FactorArray` c коэффициентом 1.5.  Поэтому, чтобы сравнить полученную реализацию со стандартом, в работу был включен также тип `STDVectorArray`, который является адаптером для `std::vector`. 

При работе с памятью использую `std::allocator`, что позволяет в перспективе подключить свои аллокаторы памяти и делает сравнение с `std::vector` более корректным. Так как `SingleArray`, `VectorArray` и `FactorArray` отличаются только размеров новой области памяти, то для реализации был использован паттерн стратегия на основе шаблонного полиморфизма. Эти типы массивов основаны на `ExtendedArray`. 

Класс `MatrixArray` реализован с помощью `VectorArray` и `SingleArray`.

Все классы массивов унаследованы от интерфейсного класса `IArray`, для унификации интерфейса, предложенного в задании. Он был расширен для поддержки константности и move-семантики.  

С учетом большого количества функций, операций и типов - нельзя было обойтись без тестирования. Программа начинается с простых автоматизированных тестов   `test_array_base`  по всем операциям для каждого типа динамического массива. Также для анализа корректности выполнения move/copy операций ручной тест `test_array_internal`.  Он закомментирован, так как подразумевает анализ лога консоли, в которую выводятся операции над объектами специального логирующего класса `A`.
Третий тест производительности для различных размеров массива, в соответствии с заданием, реализован в функции `test_array_profile`. Таблицы c результатами генерируются автоматизировано в файл Markdown. В качестве элемента используется объекты класса `B`, который считает все операции, произведенные над его объектами. В ячейке таблицы указано время выполнения и количество операций. 
Также различаются две операции `Inset(T,0)` – в новый массив, или в пустой массив пустой, но который был ранее заполнен, то есть память под элементы в нем была уже выделена. Дополнительно включен столбец со значением занимаемой массивом памяти при его максимальном заполнении.

## Краткие выводы по результатам

Результаты получены для элементов класса `B` размером 1 байт. Код собран с оптимизаций быстродействия __Release__.

1. Некоторые результаты для `SingleArray` неожиданно лучше, чем можно предположить: 
   Например, `Insert(T,0)` для нового `SingleArray`  работает быстрее, чем в пустой `SingleArray`, в котором память уже была аллоцирована ранее. Количество операций растет квадратично, но время - линейно.
  
Этот результат сбивает с толку, так как похож на ошибку, но я её не нахожу.  Гипотеза, что здесь срабатывает магическая оптимизация. Отмечу, что при выключенной оптимизации (сборка __Debug__) этой аномалии нет.

2. `VectorArray` дает выигрыш по сравнению с `SingleArray` только для операции вставке в конец.

3. `MatrixArray` оказался на крайне не эффективным. Поддержка сложной структуры требует доп. операций. При этому еще и нарушается принцип непрерывности памяти. В рамках оптимизации `MatrixArray` ввел функцию доступа к элементам `ExpandArray` без проверки выхода за границы.

4. `FactorArray` – лучше чем `SingleArray` и `VectorArray` в плане вставки в конец, но в остальных операциях преимуществ не заметно. 

5. Сравнение с `std::vector` показывает, что созданная реализация на уровне стандартного. 

По сравнению с GCC 7.3, MSVC 2019 сделал чуть более быстрый код для платформы Windows.


## Что еще можно сделать, но не было сделано


1. Исследовать природу хороших результатов для `SingleArray`

2. Можно запустить тест для "толстых" элементов, которые занимают много памяти.

3. Можно запустить тест для структурных объектов, которые поддерживают move-семантику, например, для `std::string`

Результаты для этих тесов могут отличаться от того, что получено для объекта `B`.

3. Изначально задумывал интегрировать библиотеку в Python и проверить её работу в нем, сравнив со встроенным Array. К сожалению работа съела неприлично много времени, поэтому эту часть я отложил, хотя и начинал с этого направления.
