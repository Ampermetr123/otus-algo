# otus-algo

## Описание задачи
В этом задании реализованы деревья:
- бинарное дерево поиска - BSTree;
- АВЛ дерево поиска - AVLTree;
- Splay - дерево поиска - SplayTree;

Для каждого дерева выполняются небольшие тесты
на функциональность.

Все деревья проверяются на производительность
для случая вставки случайных чисел
и для случая вставки возрастающей последовательности чисел.
Также этот тест выполняется для `std::set` (красно черные деревья) для
сопоставления полученных результатов.

Полученные измерения занесены в таблицу (файл `./report/report.md`)

## Особенности реализации и комментарии

1) В реализациях деревьях использовал умные указатели, которые обеспечивают
автоматическое освобождение всех узлов дерева. 
В `AVLTree` и `BSTree` - `share_ptr`. Узел содержит ссылку на родителя.
В `SplayTree` - `unique_ptr`. Узел не содержит ссылку на родителя.
В основном это было сделано для тренировки и интереса.
Те реализации, которые мне встречались в сети, не используют умные указатели (хотя, я сильно не интересовался и не искал).
В целом умные указатели, судя по результатам измерений и сравнению с `std::set`,  не сильно снижают производительность.
С другой стороны unique_ptr несколько ограничивает манипуляции с указателями. Так, в `SplayTree` функция `splay`  оказалась очень затратной на глубину рекурсивных вызовов. Но переписывать эту функцию без рекурсии с `unique_ptr` затруднительно.

2) Деревья имеют почти одинаковый интерфейс и встречаются похожие кодовые конструкции.
Однако, я специально не делал наследование, так как это в код стал бы менее читаем и в нем
появились бы различные компромиссы, например, преобразования типов.
